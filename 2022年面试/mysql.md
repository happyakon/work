## Mysql

### 1. Mysql中有哪几种锁？

> 1.表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
>
> 2.行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
>
> 3.页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

### 2. Mysql中有哪些引擎？

> 1. MyISAM
> 2. Heap
> 3. Merge
> 4. INNODB
> 5. ISAM

### 3. 简述在Mysql数据库中MyISAM和InnoDB的区别?

#### 1.MyISAM：

> 不支持事务，但是每次查询都是原子的；
>
> 支持表级锁，即每次操作是对整个表加锁；
>
> 存储表的总行数；
>
> 一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；
>
> 采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。

#### 2.InnoDB:

> 支持ACID的事务，支持事务的四种隔离级别；
>
> 支持行级锁及外键约束：因此可以支持写并发；
>
> 不存储总行数；
>
> 一个InnoDB引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G）；
>
> 主键索引采用聚集索引（索引的数据与存储数据文件本身），辅助索引的数据存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。

### 3.什么是聚簇索引？什么是非聚簇索引？

> 聚簇索引的叶子点中保存了完整的行记录。InnoDB中每个表都必须有一个聚簇索引，默认根据主键建立，如果表中没有主键，InnoDB会选择一个合适的列未聚簇索引，如果找不到合适的列，会使用一条隐藏的列DB_ROW_ID作为聚簇索引。
>
> 非聚簇索引的叶子点保存了主键和索引字段的值，所过查询的是索引字段，或者是主键，则不用回表查询，如果是查询其他列数据，则需要回表查询。

### 4. 列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？

> 它会停止递增，任何进一步的插入都将产生错误，因为主键冲突。

### 5. 分库？分表？分区？

> 主要是数据量过大，例如千万级甚至更多，那么在操作表的时候就会加大系统的开销。

#### 5.1 分表

##### 5.2 垂直分表

> 对于访问频率比较高的字段，作为一张表，访问频率低的字段作为一张表，例如：商品，就可以把商品名称、价格、图片作为一个表优先访问，因为在电商中，很多人都是随便翻页，后续的商品描述，厂家信息等可以作为一个表。

##### 5.2 水平分表

> 对于数据量太大的表适合水平分表。

### 5. 场景：一个表，每天5W数据量，运行三年，该如何设计？

> 777777777777777

### 7. InnoDB中有哪几种隔离级别？

| 事务隔离级别                                | 脏读 | 不可重复读 | 幻读 |
| ------------------------------------------- | ---- | ---------- | ---- |
| 读未提交（read-uncommitted）                | 是   | 是         | 是   |
| 读已提交（read-committed）**ORACLE默认**    | 否   | 是         | 是   |
| 可重复读（repeatable-read）   **MYSQL默认** | 否   | 否         | 是   |
| 串行化（serializable）                      | 否   | 否         | 否   |

### 8.  可以使用多少列创建索引？

> 任何标准表最多可以创建16个索引列。

### 9.索引的底层实现原理和优化

> B+树，经过优化的B树
>
> 主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。
>
> B+树，也叫多路搜索树，每个节点可以存储一个innoDB页的数据，每页是16KB,对于聚簇索引树来说，每个节点存储的是聚簇索引，每个索引又指向子节点，这样可以大大减少查找的次数，而且子节点的数据是横向是链表结构，适合范围查找。

### 10.索引什么时候会失效

> 1. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引。
> 2. like查询以%开头。
> 3. 对于联合索引，要符合最左前缀原则，否者不使用索引。
> 4. 如果mysql估计使用全表扫描要比使用索引快,则不使用索引，比如性别字段。

### 11.Mysql的MVCC

###### 数据读取模式：

| 读取模式 | 说明                                                         | 实现方式                                              |
| -------- | ------------------------------------------------------------ | ----------------------------------------------------- |
| 当前读   | insert、update、delete、select ... for updatge、select ... lock for share mode | 通过next-key（行锁+间隙锁）实现                       |
| 快照读   | 普通的select语句                                             | 生成ReadView,然后利用MCVV机制进行读取，不会对进行加锁 |

###### 数据读取问题：

| 问题类型   | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| 脏读       | 一个事务读取了另外一个事务未提交的数据。                     |
| 不可重复读 | 在一个事务中，多次读取一个记录的数据，结果不一致。           |
| 幻读       | 主要是insert,两个事务，第一次去读同一个不存在的ID的时候，都是null,其中有一个先做了insert,后面insert的线程就是失败，报主键冲突，如果查询用的都是for update那么有一个线程可能会报发生死锁异常。 |

> mvcc多版本并发控制，其实就是隔离级别是隔离级别RR和RC的实现方式。目的是为了降低开销。MCVV的实现是基于快照读，实现原理如下：

![mysql-mvcc](D:\gitwork\work\2022年面试\mysql\mysql-mvcc.png)

#### 11.1 RC下为什么会不可重复读

> 因为在RC的隔离级别下，每次当前读数据，ReadView否会生成一次，所以前后读到的数据可能不一致。

#### 11.2 RR下如何保证不可重复读，为什么会出现幻读

> RR下，只有第一此当前读才会生成ReadView,后续读取会服用之前生成ReadView,所以每次读取的数据都一样，但是会出现幻读。

#### 11.3 如何解决幻读的问题

> 如果是同一个方法内，并发插入同ID的数据的数据，那么可以把隔离级别设置成SERIALIZABLE,但是要确保其他方法没有这样的操作，如果有，那么所有方法对于同样ID的操作，应该使用分布式锁。

### 12.Mysql的主从复制原理？

![mysql主从复制](D:\gitwork\work\2022年面试\mysql\mysql主从复制.png)

### 13.innodb底层细节

![mysql-buffer-pool](D:\gitwork\work\2022年面试\mysql\mysql-buffer-pool.png)

#### 13.1 indoDB内存数据对象

![innodb-buffer-pool](mysql/innodb-buffer-pool.png)

#### 13.2 innodb的LRU算法

> 数据库中是使用LRU算法对缓存池进行管理，即最近最少使用的放在LRU末端，最频繁使用的页放在LRU列表的前端，当缓存池不能存放新读取的页时，将首先释放LRU列表中尾端的页。innoDB设置了一个MIDPIONT，将链表分为两段，前面的是热数据区域，后面的是冷数据区域，新来的数据页首先放在冷数据的头位置，如果再次读取到，则放入热数据的顶端位置。

#### 13.3 mysql数据读写数据是如何利用缓存池的？

> 当需要读取数据是，会检查缓存池中是否有对应的缓存页，如果没有，就从硬盘读取，放入缓冲池。当需要修改数据时，先查看缓冲池中有存不存在，如果存在，则修改缓冲池中的数据，然后再一定的频率刷新到磁盘。这个触发刷盘的操作是有checkpoint技术控制的。

#### 13.4 checkpoint技术

> 我们知道事务提交之前，是先写入redo log中，再修改页。如果redo log可以无限增大，缓冲池也足够大，能够缓冲数据库所有数据，那么就不需要将缓冲池中的页的新版本刷回到磁盘，这是基于两个前提：
>
> 1. 缓冲池可以缓冲数据库中所有的数据
> 2. redo log可以无限增大。
>
> 先看第一个条件有没有可能满足，数据库开始创建时，或者系统第一次上线时表中没有数据，缓冲池可以缓冲所有的数据，但是日积月累，用户增加，流量增加，数据量就不断增加，目前市场达到TB的数据库并不少见，但是达到TB的内存却很少见，所以生产中第一个条件很难达到。
>
> 再看第二个条件，redo log 可以无限增大，但是这对成本的要求太高，也不便于运维，DBA不知道什么时候redo log是否已经接近磁盘阈值，并且还需要让存储设备支持动态可扩展。
>
> 即便前面两个条件都满足，但是服务器运行了几个月或者几年，一旦宕机或者崩溃，通过redo log恢复数据的时间会非常久，代价太大。

##### 13.4.1 checkpoint主要解决问题：

> 1. 缩短数据恢复时间
> 2. 缓冲池不够时，将脏页刷新到磁盘
> 3. redo log不可用时，刷新脏页
>
> 1.当数据库宕机的时候，数据库不需要重做所有的redo log，因为checkpoint之前的页都已经刷新到磁盘，数据库只需要对checkpoint后的redo log进行恢复即可。
>
> 2.当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，如果是脏页，则执行checkpoint，将脏页刷新到磁盘。
>
> 3.redo log不可用的情况是指，redo log不是无限增大的，而是循环使用的，redo log被重用的部分是指这些redo log已经不在需要，若服务器发生宕机，数据库恢复操作不需要这部分的数据，因此这部分可以被覆盖重用，若此时redo log还需要使用，那就必须强制checkpoint，至少将缓冲池中的页刷到当前redo log的位置。
>
> 4.还有一种情况就是脏页太多，也会强制checkpoint，目的是为了保证缓冲池中有足够可用的页。

#### 14 MySql有哪些日志

> 1. **bin log**
> 2. **undo log**
> 3. **redo log**
> 3. slow log 慢日志
> 3. 查询日志
> 3. 错误日志

#### 14.1 binlog（mysql server产生的二进制日志）

> binlog记录了所有对mysql执行更改的操作，select和show这类的操作不会改变数据，因而不会记录在内。二进制日志主要的作用是：
>
> 1. 恢复
>
>    某些数据的恢复需要二进制日志，例如在一个数据库全备文件恢复后，日志可以通过二进制日志进行point-in-time的恢复。
>
> 2. 复制
>
>    其原理和复制类似，通过复制和执行二进制文件使一台远程数据库和另一台远程数据库进行实时同步。
>
> 3. 审计
>
>    用户可以通过二进制文件进行审计，看是否有注入的攻击。

#### 14.2 undo log（innoDB产生）

> 如果说redo log日志使物理日志的话，undo log就是逻辑日志，相当于操作的反日志，你新增，它记录删除，你修改，它保存原来的值，你删除，他就新增，里面存的内容未自增事务ID、rowid,回归指针、用户数据。多个Undo log可以组成一个链表，用于MCVV,多版本并发控制。

#### 14.3 redo log(innoDB产生)

> redo log 是为了保证持久性，防止服务器崩溃或者宕机的时候造成数据丢失，每次事务提交之前，都会先将数据写到redo log中，redo log主要写的内容主要是关于每个页更改的物理情况。

### 15 后台线程

#### 15.1 Master Thread

> 主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性。包括脏页的刷新，合并插入缓冲（INSERT BUFFER），UNDO页的回收等

#### 15.2 IO Thread

> innoDB中大量使用AIO来处理IO请求，这样可以极大的提高数据库的性能，而IO Thread主要负责这些IO的回调。

#### 15.3 purge Thread

> 事务被提交以后，其所使用的undolog可能就不再需要，mysql 1.1版本之前，undolog回收工作是由Master Threadx线程来做的，从1.1版本开始，有purge Thread线程来做这件事，以此来减轻Master Thread线程的压力，从而提高CPU的使用率。

#### 15.4 Page Cleaner Thread

> 从1.2版本开始，脏页的刷新由此线程来做，同样是减少Master Thread的压力。

### 16 mysql如何优化

> 从软件到硬件。
>
> 1. SQL语句及索引的优化
>
>    a. where子句中：where表之间的连接必须写在其他where条件之前，那些可以过滤掉最大数量记录的条件必须写在where子句的末尾.HAVING最后。
>
>    b. 用EXISTS替代IN、用NOT EXISTS替代NOT IN。
>
>    c. 避免在索引列上使用计算
>
>    d. 避免在索引列上使用IS NULL和IS NOT NULL
>
>    e. 对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。
>
>    f. 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描
>
>    g. 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描
>
> 2. 数据库表结构的优化
>
>    a. 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。
>    b. 选择合适的表字段数据类型和存储引擎，适当的添加索引。
>    c. mysql库主从读写分离。
>    d. 找规律分表，减少单表中的数据量提高查询速度。
>    e.添加缓存机制，比如redis。
>
> 3. 系统配置的优化
>
>    a. innodb_buffer_pool_size: 缓冲池是数据和索引缓存的地方：这个值越大越好，这能保证你在大多数的读取操作时使用的是[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)而不是硬盘。如果是纯数据库，可以设置到机器内存80%(官网建议)
>
>    b. innodb_log_file_size: 对于写入负载高的场景,适当调大redo log的值
>
> 4. 硬件的优化
>
>    a.增大内存和cpu
>
>    b.读写分离中的模式中，横向扩展。
