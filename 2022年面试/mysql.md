## Mysql

### 1. Mysql中有哪几种锁？

> 1.表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
>
> 2.行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。
>
> 3.页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

### 2. Mysql中有哪些引擎？

> 1. MyISAM
> 2. Heap
> 3. Merge
> 4. INNODB
> 5. ISAM

### 3. 简述在Mysql数据库中MyISAM和InnoDB的区别?

#### 1.MyISAM：

> 不支持事务，但是每次查询都是原子的；
>
> 支持表级锁，即每次操作是对整个表加锁；
>
> 存储表的总行数；
>
> 一个MYISAM表有三个文件：索引文件、表结构文件、数据文件；
>
> 采用非聚集索引，索引文件的数据域存储指向数据文件的指针。辅索引与主索引基本一致，但是辅索引不用保证唯一性。

#### 2.InnoDB:

> 支持ACID的事务，支持事务的四种隔离级别；
>
> 支持行级锁及外键约束：因此可以支持写并发；
>
> 不存储总行数；
>
> 一个InnoDB引擎存储在一个文件空间（共享表空间，表大小不受操作系统控制，一个表可能分布在多个文件里），也有可能为多个（设置为独立表空，表大小受操作系统文件大小限制，一般为2G）；
>
> 主键索引采用聚集索引（索引的数据与存储数据文件本身），辅助索引的数据存储主键的值；因此从辅索引查找数据，需要先通过辅索引找到主键值，再访问辅索引；最好使用自增主键，防止插入数据时，为维持B+树结构，文件的大调整。

### 3.什么是聚簇索引？什么是非聚簇索引？

> 聚簇索引的叶子点中保存了完整的行记录。InnoDB中每个表都必须有一个聚簇索引，默认根据主键建立，如果表中没有主键，InnoDB会选择一个合适的列未聚簇索引，如果找不到合适的列，会使用一条隐藏的列DB_ROW_ID作为聚簇索引。
>
> 非聚簇索引的叶子点保存了主键和索引字段的值，所过查询的是索引字段，或者是主键，则不用回表查询，如果是查询其他列数据，则需要回表查询。

### 4. 列设置为AUTO INCREMENT时，如果在表中达到最大值，会发生什么情况？

> 它会停止递增，任何进一步的插入都将产生错误，因为主键冲突。

### 5. 什么是分库分表？为什么有时候需要分库分表？

### 6. 水平拆分和垂直拆分如何判断，举个例子？

### 7. InnoDB中有哪几种隔离级别？

| 事务隔离级别                                | 脏读 | 不可重复读 | 幻读 |
| ------------------------------------------- | ---- | ---------- | ---- |
| 读未提交（read-uncommitted）                | 是   | 是         | 是   |
| 不可重复读（read-committed）**ORACLE默认**  | 否   | 是         | 是   |
| 可重复读（repeatable-read）   **MYSQL默认** | 否   | 否         | 是   |
| 串行化（serializable）                      | 否   | 否         | 否   |

### 8.  可以使用多少列创建索引？

> 任何标准表最多可以创建16个索引列。

### 9.索引的底层实现原理和优化

> B+树，经过优化的B树
>
> 主要是在所有的叶子结点中增加了指向下一个叶子节点的指针，因此InnoDB建议为大部分表使用默认自增的主键作为主索引。
>
> B+树，也叫多路搜索树，每个节点可以存储一个innoDB页的数据，每页是16KB,对于聚簇索引树来说，每个节点存储的是聚簇索引，每个索引又指向子节点，这样可以大大减少查找的次数，而且子节点的数据是横向是链表结构，适合范围查找。

### 10.索引什么时候会失效

> 1. 如果列类型是字符串，那一定要在条件中将数据使用引号引用起来,否则不使用索引。
> 2. like查询以%开头。
> 3. 对于联合索引，要符合最左前缀原则，否者不使用索引。
> 4. 如果mysql估计使用全表扫描要比使用索引快,则不使用索引，比如性别字段。

### 11.Mysql的MVCC

> mvcc多版本并发控制，其实就是隔离级别为可重复读的实现。

### 12.Mysql的主从复制原理

### 13.innodb底层细节

#### 13.1 indoDB内存数据对象

![innodb-buffer-pool](mysql/innodb-buffer-pool.png)

#### 13.2 innodb的LRU算法

> 数据库中是使用LRU算法对缓存池进行管理，即最近最少使用的放在LRU末端，最频繁使用的页放在LRU列表的前端，当缓存池不能存放新读取的页时，将首先释放LRU列表中尾端的页。innoDB设置了一个MIDPIONT，将链表分为两段，前面的是热数据区域，后面的是冷数据区域，新来的数据页首先放在冷数据的头位置，如果再次读取到，则放入热数据的顶端位置。

#### 13.3 mysql数据读写数据是如何利用缓存池的？

> 当需要读取数据是，会检查缓存池中是否有对应的缓存页，如果没有，就从硬盘读取，放入缓冲池。当需要修改数据时，先查看缓冲池中有存不存在，如果存在，则修改缓冲池中的数据，然后再一定的频率刷新到磁盘。这个触发刷盘的操作是有checkpoint技术控制的。

#### 13.4 checkpoint技术

> 我们知道事务提交之前，是先写入redo log中，再修改页。如果redo log可以无限增大，缓冲池也足够大，能够缓冲数据库所有数据，那么就不需要将缓冲池中的页的新版本刷回到磁盘，这是基于两个前提：
>
> 1. 缓冲池可以缓冲数据库中所有的数据
> 2. redo log可以无限增大。
>
> 先看第一个条件有没有可能满足，数据库开始创建时，或者系统第一次上线时表中没有数据，缓冲池可以缓冲所有的数据，但是日积月累，用户增加，流量增加，数据量就不断增加，目前市场达到TB的数据库并不少见，但是达到TB的内存却很少见，所以生产中第一个条件很难达到。
>
> 再看第二个条件，redo log 可以无限增大，但是这对成本的要求太高，也不便于运维，DBA不知道什么时候redo log是否已经接近磁盘阈值，并且还需要让存储设备支持动态可扩展。
>
> 即便前面两个条件都满足，但是服务器运行了几个月或者几年，一旦宕机或者崩溃，通过redo log恢复数据的时间会非常久，代价太大。

##### 13.4.1 checkpoint主要解决问题：

> 1. 缩短数据恢复时间
> 2. 缓冲池不够时，将脏页刷新到磁盘
> 3. redo log不可用时，刷新脏页
>
> 1.当数据库宕机的时候，数据库不需要重做所有的redo log，因为checkpoint之前的页都已经刷新到磁盘，数据库只需要对checkpoint后的redo log进行恢复即可。
>
> 2.当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，如果是脏页，则执行checkpoint，将脏页刷新到磁盘。
>
> 3.redo log不可用的情况是指，redo log不是无限增大的，而是循环使用的，redo log被重用的部分是指这些redo log已经不在需要，若服务器发生宕机，数据库恢复操作不需要这部分的数据，因此这部分可以被覆盖重用，若此时redo log还需要使用，那就必须强制checkpoint，至少将缓冲池中的页刷到当前redo log的位置。
>
> 4.还有一种情况就是脏页太多，也会强制checkpoint，目的是为了保证缓冲池中有足够可用的页。

#### 14 MySql有哪些日志

> 1. **bin log**
> 2. **undo log**
> 3. **redo log**
> 3. slow log 慢日志
> 3. 查询日志
> 3. 错误日志

#### 14.1 binlog（mysql server产生的二进制日志）

> binlog记录了所有对mysql执行更改的操作，select和show这类的操作不会改变数据，因而不会记录在内。二进制日志主要的作用是：
>
> 1. 恢复
>
>    某些数据的恢复需要二进制日志，例如在一个数据库全备文件恢复后，日志可以通过二进制日志进行point-in-time的恢复。
>
> 2. 复制
>
>    其原理和复制类似，通过复制和执行二进制文件使一台远程数据库和另一台远程数据库进行实时同步。
>
> 3. 审计
>
>    用户可以通过二进制文件进行审计，看是否有注入的攻击。

#### 14.2 undo log（innoDB产生）

> 如果说redo log日志使物理日志的话，undo log就是逻辑日志，相当于操作的反日志，你新增，它记录删除，你修改，它保存原来的值，你删除，他就新增，里面存的内容未自增事务ID、rowid,回归指针、用户数据。多个Undo log可以组成一个链表，用于MCVV,多版本并发控制。

#### 14.3 redo log(innoDB产生)

> redo log 是为了保证持久性，防止服务器崩溃或者宕机的时候造成数据丢失，每次事务提交之前，都会先将数据写到redo log中，redo log主要写的内容主要是关于每个页更改的物理情况。

### 15 后台线程

#### 15.1 Master Thread

> 主要负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性。包括脏页的刷新，合并插入缓冲（INSERT BUFFER），UNDO页的回收等

#### 15.2 IO Thread

> innoDB中大量使用AIO来处理IO请求，这样可以极大的提高数据库的性能，而IO Thread主要负责这些IO的回调。

#### 15.3 purge Thread

> 事务被提交以后，其所使用的undolog可能就不再需要，mysql 1.1版本之前，undolog回收工作是由Master Threadx线程来做的，从1.1版本开始，有purge Thread线程来做这件事，以此来减轻Master Thread线程的压力，从而提高CPU的使用率。

#### 15.4 Page Cleaner Thread

> 从1.2版本开始，脏页的刷新由此线程来做，同样是减少Master Thread的压力。

